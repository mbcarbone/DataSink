# tests/test_core.py
# Pytest file for testing the core logic in core.py

import os
import shutil
import pytest
from pathlib import Path
from unittest.mock import patch, MagicMock

# We import the functions to be tested
from core import sync_data, is_safe_path

# --- Test Fixtures and Setup ---

TEST_SOURCE_DIR = "test_source"
TEST_DEST_DIR = "test_dest"
TEST_SOURCE_FILE = os.path.join(TEST_SOURCE_DIR, "test_file.txt")

def setup_function():
    """Create fresh test directories and a sample file for each test."""
    if os.path.exists(TEST_SOURCE_DIR):
        shutil.rmtree(TEST_SOURCE_DIR)
    if os.path.exists(TEST_DEST_DIR):
        shutil.rmtree(TEST_DEST_DIR)

    os.makedirs(os.path.join(TEST_SOURCE_DIR, "subfolder"), exist_ok=True)
    os.makedirs(TEST_DEST_DIR, exist_ok=True)
    with open(TEST_SOURCE_FILE, "w") as f:
        f.write("This is a test file.")

def teardown_function():
    """Remove test directories and files after each test."""
    if os.path.exists(TEST_SOURCE_DIR):
        shutil.rmtree(TEST_SOURCE_DIR)
    if os.path.exists(TEST_DEST_DIR):
        shutil.rmtree(TEST_DEST_DIR)

# --- Happy and Unhappy Path Tests ---

def test_move_file_success():
    """Tests the successful move of a single file."""
    success, message = sync_data(TEST_SOURCE_FILE, TEST_DEST_DIR, 'move')
    assert success is True
    assert "Successfully moved" in message
    assert os.path.exists(os.path.join(TEST_DEST_DIR, "test_file.txt"))
    assert not os.path.exists(TEST_SOURCE_FILE)

def test_invalid_operation_for_file():
    """Tests providing an invalid operation for a file."""
    success, message = sync_data(TEST_SOURCE_FILE, TEST_DEST_DIR, 'delete')
    assert success is False
    assert "Invalid operation 'delete'" in message

def test_invalid_operation_for_directory():
    """Tests providing an invalid operation for a directory."""
    success, message = sync_data(TEST_SOURCE_DIR, TEST_DEST_DIR, 'delete')
    assert success is False
    assert "Invalid operation 'delete'" in message

@patch('shutil.copytree', side_effect=shutil.Error("Mock shutil error"))
def test_shutil_error_handling(mock_copytree):
    """Tests the generic shutil.Error exception handling."""
    success, message = sync_data(TEST_SOURCE_DIR, TEST_DEST_DIR, 'copy')
    assert success is False
    assert "An error occurred" in message

def test_error_on_copying_directory_into_itself():
    """Tests that the self-copy protection mechanism works correctly."""
    dest_subdir = os.path.join(TEST_SOURCE_DIR, "subfolder")
    success, message = sync_data(TEST_SOURCE_DIR, dest_subdir, 'copy')
    assert success is False
    assert "Cannot copy or move a directory into itself" in message

@patch('pathlib.Path.mkdir') # Corrected patch target
def test_destination_creation_os_error(mock_mkdir):
    """Tests that an OSError during destination creation is handled."""
    mock_mkdir.side_effect = OSError("Permission denied")
    shutil.rmtree(TEST_DEST_DIR) # Ensure destination doesn't exist
    success, message = sync_data(TEST_SOURCE_FILE, TEST_DEST_DIR, 'copy')
    assert success is False
    assert "Could not create destination directory" in message

def test_move_directory_to_existing_destination():
    """Tests moving a directory to a location where the target already exists."""
    dest_with_source_name = os.path.join(TEST_DEST_DIR, TEST_SOURCE_DIR)
    os.makedirs(dest_with_source_name, exist_ok=True)
    with open(os.path.join(dest_with_source_name, "old_file.txt"), "w") as f:
        f.write("This should be deleted.")

    success, message = sync_data(TEST_SOURCE_DIR, TEST_DEST_DIR, 'move')
    assert success is True
    assert "Successfully moved" in message
    assert os.path.exists(os.path.join(TEST_DEST_DIR, TEST_SOURCE_DIR, "test_file.txt"))
    assert not os.path.exists(os.path.join(TEST_DEST_DIR, TEST_SOURCE_DIR, "old_file.txt"))
    assert not os.path.exists(TEST_SOURCE_DIR)

def test_move_directory_to_new_destination():
    """
    Tests moving a directory to a new destination that does not
    contain the source directory name yet.
    """
    success, message = sync_data(TEST_SOURCE_DIR, TEST_DEST_DIR, 'move')
    assert success is True
    assert "Successfully moved" in message
    assert os.path.isdir(os.path.join(TEST_DEST_DIR, TEST_SOURCE_DIR))
    assert not os.path.exists(TEST_SOURCE_DIR)

@patch('core.Path.mkdir') # Add this patch to prevent the premature error
@patch('core.Path.is_dir', return_value=False)
@patch('core.Path.is_file', return_value=False)
def test_source_is_not_file_or_dir(mock_is_file, mock_is_dir, mock_mkdir):
    """Tests the final 'else' block for an invalid source type."""
    success, message = sync_data(TEST_SOURCE_DIR, TEST_DEST_DIR, 'copy')
    assert success is False
    assert "is not a file or directory" in message

def test_self_copy_check_with_nonexistent_dest():
    """
    Tests the self-copy check's 'except FileNotFoundError' block by providing
    a destination that doesn't exist but is a child of the source.
    """
    non_existent_dest = os.path.join(TEST_SOURCE_DIR, "non_existent_subfolder")
    success, message = sync_data(TEST_SOURCE_DIR, non_existent_dest, 'copy')
    assert success is False
    assert "Cannot copy or move a directory into itself" in message

@patch('shutil.copy2', side_effect=OSError("Disk full"))
def test_generic_os_error_on_file_copy(mock_copy2):
    """
    Tests the final 'except' block by simulating an OSError during a file copy.
    """
    success, message = sync_data(TEST_SOURCE_FILE, TEST_DEST_DIR, 'copy')
    assert success is False
    assert "An error occurred during the 'copy' operation: Disk full" in message

# --- is_safe_path Specific Tests ---

def test_is_safe_path_for_safe_paths():
    """Tests that is_safe_path correctly identifies safe paths."""
    assert is_safe_path(Path.cwd() / "safe_subdir") is True
    assert is_safe_path(Path.home() / "safe_subdir") is True

def test_is_safe_path_for_unsafe_paths():
    """Tests that is_safe_path correctly identifies unsafe paths."""
    assert is_safe_path(Path("/etc/")) is False

@patch('pathlib.Path.resolve')
def test_is_safe_path_handles_runtime_error(mock_resolve):
    """Tests the except block for broken symbolic links."""
    mock_resolve.side_effect = RuntimeError("Broken symlink")
    assert is_safe_path(Path.cwd() / "some_path") is True

@patch('core.Path.home', side_effect=Exception("Unexpected mock error"))
def test_is_safe_path_handles_unexpected_error(mock_home):
    """Tests the generic 'except Exception' block in is_safe_path."""
    assert is_safe_path(Path(TEST_DEST_DIR)) is False

